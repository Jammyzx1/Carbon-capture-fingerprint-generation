<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8">
<meta name="viewport" content="width=device-width, initial-scale=1, minimum-scale=1" />
<meta name="generator" content="pdoc 0.10.0" />
<title>ccsfp.informatics.chemical_space_map API documentation</title>
<meta name="description" content="This module is intended to allow one to easily build a force directed graph of chemical space using the networkx python modules …" />
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/sanitize.min.css" integrity="sha256-PK9q560IAAa6WVRRh76LtCaI8pjTJ2z11v0miyNNjrs=" crossorigin>
<link rel="preload stylesheet" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/10up-sanitize.css/11.0.1/typography.min.css" integrity="sha256-7l/o7C8jubJiy74VsKTidCy1yBkRtiUGbVkYBylBqUg=" crossorigin>
<link rel="stylesheet preload" as="style" href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/styles/github.min.css" crossorigin>
<style>:root{--highlight-color:#fe9}.flex{display:flex !important}body{line-height:1.5em}#content{padding:20px}#sidebar{padding:30px;overflow:hidden}#sidebar > *:last-child{margin-bottom:2cm}.http-server-breadcrumbs{font-size:130%;margin:0 0 15px 0}#footer{font-size:.75em;padding:5px 30px;border-top:1px solid #ddd;text-align:right}#footer p{margin:0 0 0 1em;display:inline-block}#footer p:last-child{margin-right:30px}h1,h2,h3,h4,h5{font-weight:300}h1{font-size:2.5em;line-height:1.1em}h2{font-size:1.75em;margin:1em 0 .50em 0}h3{font-size:1.4em;margin:25px 0 10px 0}h4{margin:0;font-size:105%}h1:target,h2:target,h3:target,h4:target,h5:target,h6:target{background:var(--highlight-color);padding:.2em 0}a{color:#058;text-decoration:none;transition:color .3s ease-in-out}a:hover{color:#e82}.title code{font-weight:bold}h2[id^="header-"]{margin-top:2em}.ident{color:#900}pre code{background:#f8f8f8;font-size:.8em;line-height:1.4em}code{background:#f2f2f1;padding:1px 4px;overflow-wrap:break-word}h1 code{background:transparent}pre{background:#f8f8f8;border:0;border-top:1px solid #ccc;border-bottom:1px solid #ccc;margin:1em 0;padding:1ex}#http-server-module-list{display:flex;flex-flow:column}#http-server-module-list div{display:flex}#http-server-module-list dt{min-width:10%}#http-server-module-list p{margin-top:0}.toc ul,#index{list-style-type:none;margin:0;padding:0}#index code{background:transparent}#index h3{border-bottom:1px solid #ddd}#index ul{padding:0}#index h4{margin-top:.6em;font-weight:bold}@media (min-width:200ex){#index .two-column{column-count:2}}@media (min-width:300ex){#index .two-column{column-count:3}}dl{margin-bottom:2em}dl dl:last-child{margin-bottom:4em}dd{margin:0 0 1em 3em}#header-classes + dl > dd{margin-bottom:3em}dd dd{margin-left:2em}dd p{margin:10px 0}.name{background:#eee;font-weight:bold;font-size:.85em;padding:5px 10px;display:inline-block;min-width:40%}.name:hover{background:#e0e0e0}dt:target .name{background:var(--highlight-color)}.name > span:first-child{white-space:nowrap}.name.class > span:nth-child(2){margin-left:.4em}.inherited{color:#999;border-left:5px solid #eee;padding-left:1em}.inheritance em{font-style:normal;font-weight:bold}.desc h2{font-weight:400;font-size:1.25em}.desc h3{font-size:1em}.desc dt code{background:inherit}.source summary,.git-link-div{color:#666;text-align:right;font-weight:400;font-size:.8em;text-transform:uppercase}.source summary > *{white-space:nowrap;cursor:pointer}.git-link{color:inherit;margin-left:1em}.source pre{max-height:500px;overflow:auto;margin:0}.source pre code{font-size:12px;overflow:visible}.hlist{list-style:none}.hlist li{display:inline}.hlist li:after{content:',\2002'}.hlist li:last-child:after{content:none}.hlist .hlist{display:inline;padding-left:1em}img{max-width:100%}td{padding:0 .5em}.admonition{padding:.1em .5em;margin-bottom:1em}.admonition-title{font-weight:bold}.admonition.note,.admonition.info,.admonition.important{background:#aef}.admonition.todo,.admonition.versionadded,.admonition.tip,.admonition.hint{background:#dfd}.admonition.warning,.admonition.versionchanged,.admonition.deprecated{background:#fd4}.admonition.error,.admonition.danger,.admonition.caution{background:lightpink}</style>
<style media="screen and (min-width: 700px)">@media screen and (min-width:700px){#sidebar{width:30%;height:100vh;overflow:auto;position:sticky;top:0}#content{width:70%;max-width:100ch;padding:3em 4em;border-left:1px solid #ddd}pre code{font-size:1em}.item .name{font-size:1em}main{display:flex;flex-direction:row-reverse;justify-content:flex-end}.toc ul ul,#index ul{padding-left:1.5em}.toc > ul > li{margin-top:.5em}}</style>
<style media="print">@media print{#sidebar h1{page-break-before:always}.source{display:none}}@media print{*{background:transparent !important;color:#000 !important;box-shadow:none !important;text-shadow:none !important}a[href]:after{content:" (" attr(href) ")";font-size:90%}a[href][title]:after{content:none}abbr[title]:after{content:" (" attr(title) ")"}.ir a:after,a[href^="javascript:"]:after,a[href^="#"]:after{content:""}pre,blockquote{border:1px solid #999;page-break-inside:avoid}thead{display:table-header-group}tr,img{page-break-inside:avoid}img{max-width:100% !important}@page{margin:0.5cm}p,h2,h3{orphans:3;widows:3}h1,h2,h3,h4,h5,h6{page-break-after:avoid}}</style>
<script defer src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/10.1.1/highlight.min.js" integrity="sha256-Uv3H6lx7dJmRfRvH8TH6kJD1TSK1aFcwgx+mdg3epi8=" crossorigin></script>
<script>window.addEventListener('DOMContentLoaded', () => hljs.initHighlighting())</script>
</head>
<body>
<main>
<article id="content">
<header>
<h1 class="title">Module <code>ccsfp.informatics.chemical_space_map</code></h1>
</header>
<section id="section-intro">
<p>This module is intended to allow one to easily build a force directed graph of chemical space using the networkx python modules.</p>
<p>The codes require a pandas dataframe containing columns of names, smiles and a property of interest. The column names and the dataframe are
provided as input. The nodes are shaded based on the proptery and connected based on Tanimoto similarity from the smiles strings. A node 2D
coordinate set can be passed and the nearest molecules nodes will be annoted with moleucles images and names.</p>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">#!/usr/bin/env python
# Copyright IBM Corporation 2022.
# SPDX-License-Identifier: MIT
# https://www.rdkit.org/docs/GettingStartedInPython.html
# creative commons sa 4.0 tutorial used to learn rdkit methods
# https://creativecommons.org/licenses/by-sa/4.0/
# (C) 2007-2021 by Greg Landrum
&#34;&#34;&#34;
This module is intended to allow one to easily build a force directed graph of chemical space using the networkx python modules.

The codes require a pandas dataframe containing columns of names, smiles and a property of interest. The column names and the dataframe are
provided as input. The nodes are shaded based on the proptery and connected based on Tanimoto similarity from the smiles strings. A node 2D
coordinate set can be passed and the nearest molecules nodes will be annoted with moleucles images and names.
&#34;&#34;&#34;
# Python packages and utilities
from __future__ import annotations

import json
import logging
import os
import time

import matplotlib.pyplot as plt
import networkx as nx
import numpy as np
import pandas as pd
import rdkit
from matplotlib.offsetbox import AnnotationBbox
from matplotlib.offsetbox import OffsetImage
from rdkit import Chem
from rdkit.Chem import AllChem
from rdkit.Chem import DataStructs
from rdkit.Chem import Draw
from rdkit.Chem import rdMolDescriptors

from ccsfp.informatics import finger_prints as fp
from ccsfp.informatics import molecules_and_images as mai

# RDKit
# Logging
# networkx
# matplotlib
# own modules

random_seed = 15791


def build_nx_graph(
    df: pd.DataFrame,
    prop_key: str = &#34;property&#34;,
    smiles_key: str = &#34;smiles&#34;,
    label_key: str = &#34;names&#34;,
    distance: bool = False,
    fingerprints: list = None,
    connection_threshold: float = 0.7,
    connect_all: bool = False,
    graph_file_name: str = None,
    similarity_distance_list: list = None,
    node_attributes: list = None,
) -&gt; nx.Graph:
    &#34;&#34;&#34;
    Function to build a defualt graph for chemical space map plots
    :param df: pandas dataframe - dataframe with at least a label column, smiles column and property column
    :param prop_key: str - column key for property of interest values
    :param smiles_key: str - column key for smiles of molecule srings
    :param label_key: str - column key for each entries labels
    :param distance: bool - use distance rather than similarity (distance = 1.0 - similarity)
    :param fingerprints: list - if None will use Morgan fingerprint radius 2 and 2048 bits users can input a list
                                otherwise of precomputed fingerprints from RDkit or ccsfp finger_print module should
                                be an RDKit ExplicitBitVect
    :param connection_threshold: float - the value that must be &gt;= the similarity of distance to connect (form an edge)
                                         between two nodes
    :param connect_all: bool - connect all nodes with and apply to edge colour the value of grey those edges that don&#39;t
                               meet the threshold
    :param graph_file_name: str - if None don&#39;t save a pickle (pkl) of the graph other wise save a pkl file of the graph
                                  with this filename
    :param similarity_distance_list: list - pre-computed list of the similarity or distance list if none these are
                                            computed as Tanimoto similarities or distances
    :param node_attributes: : list of dicts - Should be in the same order as the rows of the df the list index which
                                              maps to the row index of df will have its dictionary added as node
                                              attributes
    :return: networkx.Graph() object
    &#34;&#34;&#34;

    log = logging.Logger(__name__)

    log.info(
        &#34;Starting to build the chemical space graph, this can take quite some time .....&#34;,
    )
    if fingerprints is None:
        log.info(
            &#34;No fingerprints given by user, will use Morgan circular fingerprints radius 2 bit length 2048.&#34;,
        )
        fps = [
            AllChem.GetMorganFingerprintAsBitVect(
                Chem.MolFromSmiles(s), radius=2, nBits=2048,
            )
            for s in df[smiles_key].values
        ]
    else:
        fps = fingerprints

    log.info(&#34;Fingerprints: {}&#34;.format(fps))

    if similarity_distance_list is None:
        log.info(&#34;No smilarity/distance list given by user, will use Tanimoto metric&#34;)
        tc = [
            DataStructs.cDataStructs.BulkTanimotoSimilarity(fps[inx], fps)
            for inx in range(len(fps))
        ]
    else:
        tc = similarity_distance_list

    log.info(&#34;Tanimoto similarity: {}&#34;.format(tc))

    # similarity or distance metrics - Not if you want to use a custom distance leave distance as False and pass in
    df_weights = pd.DataFrame(data=np.array(tc))
    if distance is True:
        df_weights = 1.0 - df_weights

    # initialize graph
    g = nx.Graph()

    # Start to build the graph with the nodes from the raw data
    if node_attributes is not None:
        for index, row in df.iterrows():
            log.debug(&#34;Index: {}&#34;.format(index))

            na = node_attributes[index]
            if not isinstance(dict, na):
                log.warning(
                    &#34;WARNING - node_attribute index {} is not a dictionary {}\n{}&#34;.format(
                        index, type(na), na,
                    ),
                )
                raise RuntimeError(
                    &#34;ERROR - node attribute {} is not a dictionary&#34;.format(
                        index),
                )

            m = mai.smiles_to_molecule(row[smiles_key])

            g.add_node(
                index,
                smiles=row[smiles_key],
                name=row[label_key],
                fingerprint=fps[index],
                fingerprint_string=fp.bits_to_text(fps[index]),
                inchi=Chem.inchi.MolToInchi(m),
                inchikey=Chem.inchi.MolToInchiKey(m),
                mr=Chem.rdMolDescriptors.CalcExactMolWt(m),
                prop=row[prop_key],
                **na,
            )

    else:
        for index, row in df.iterrows():
            log.debug(&#34;Index: {}&#34;.format(index))

            m = mai.smiles_to_molecule(row[smiles_key])

            g.add_node(
                index,
                smiles=row[smiles_key],
                name=row[label_key],
                fingerprint=fps[index],
                fingerprint_string=fp.bits_to_text(fps[index]),
                inchi=Chem.inchi.MolToInchi(m),
                inchikey=Chem.inchi.MolToInchiKey(m),
                mr=Chem.rdMolDescriptors.CalcExactMolWt(m),
                prop=row[prop_key],
            )

    log.info(&#34;Number of nodes {}&#34;.format(len(list(g.nodes))))

    # Add connections
    edges = []

    if connect_all is True:
        log.info(&#34;Connecting all&#34;)

    for i in df_weights.index:
        for j in df_weights.index[i + 1:]:
            log.debug(&#34;Considering connection between node {} {}&#34;.format(i, j))
            if df_weights.loc[i, j] &gt;= connection_threshold:
                edges.append(
                    (i, j, {&#34;weight&#34;: df_weights.loc[i, j], &#34;color&#34;: &#34;blue&#34;}))
            else:
                if connect_all is True:
                    edges.append(
                        (i, j, {
                         &#34;weight&#34;: df_weights.loc[i, j], &#34;color&#34;: &#34;grey&#34;}),
                    )

    g.add_edges_from(edges)

    if graph_file_name is not None:
        if not os.path.isfile(graph_file_name):
            nx.readwrite.gpickle.write_gpickle(g, graph_file_name)
        else:
            current_time = time.strftime(&#34;%-Y%m-%d-%H-%M-%S&#34;)
            graph_file_name = &#34;{}_{}.pkl&#34;.format(graph_file_name, current_time)
            log.info(&#34;File already existed will save to {}&#34;.format(
                graph_file_name))
            nx.readwrite.gpickle.write_gpickle(g, graph_file_name)

    return g


def plot_graph(
    g: nx.Graph,
    opt_dist: float = None,
    weight: str = None,
    iterations: int = 50,
    random_seed: int = 7,
    figure_size: tuple = (20, 20),
    node_colours: str = &#34;b&#34;,
    node_size: int = 20,
    cmap: plt.cm = plt.cm.rainbow,
    file_name_no_extension: str = &#34;graph&#34;,
    return_positions_only: bool = False,
    return_image_only: bool = False,
):
    &#34;&#34;&#34;
    A function to set node positions using the spring layout. This is a deterministic layout (if you set the seed) using
    a form of annealing. It uses the Fruchterman-Reingold force-directed algorithm. In simple terms the algorithm treats
    nodes as repulsive, connected nodes (i.e. they share an edge) are attracted to one another using the weight factor,
    if specified, where weight is the edge attribute holding a float as attractive strength. If weight is None all
    connected nodes are equally attractive, larger weight means more attractive. The opt_dist sets the optimal distance
    between nodes
    :param g: networkx Graph - Graph instance
    :param opt_dist: float - Optimal distance between nodes
    :param weight: str - edge attribute to use to determine the attractive force between nodes
    :param iterations: int - Number of annealing iterations to use
    :param random_seed: int - seed for node positions
    :param figure_size: tuple - size of the graph image
    :param node_colours: str or list - single colour str in matplotlib format or list of specific colours for each node
                                       in order of the node numbers
    :param node_size: int - Size of the nodes in the image
    :param cmap: matplotlib colormap - colormap
    :param file_name_no_extension: str - string to use to save positions and image to without an extension
    :param return_positions_only: bool - return only the positions not an image of the graph
    :param return_image_only: - return only and image not the positions
    :return: return_positions_only=False and return_image_only=False then return = dict, matplotlib figure
             return_positions_only=True and return_image_only=False then return = dict
             return_positions_only=False and return_image_only=True then return = matplotlib figure
             return_positions_only=True and return_image_only=True then return = dict
    &#34;&#34;&#34;

    log = logging.getLogger(__name__)

    log.info(&#34;Setting nodes .....&#34;)
    position = nx.spring_layout(
        g, k=opt_dist, weight=weight, iterations=iterations, seed=random_seed,
    )

    pos_out = {k: ent.tolist() for k, ent in position.items()}

    positions_filename = &#34;{}_positions&#34;.format(file_name_no_extension)
    if not os.path.isfile(&#34;{}.json&#34;.format(positions_filename)):
        with open(&#34;{}.json&#34;.format(positions_filename), &#34;w&#34;) as jout:
            json.dump(pos_out, jout, indent=4)
    else:
        current_time = time.strftime(&#34;%-Y%m-%d-%H-%M-%S&#34;)
        positions_filename = &#34;{}_{}&#34;.format(positions_filename, current_time)
        log.info(&#34;File already existed will save to {}.json&#34;.format(
            positions_filename))
        with open(&#34;{}.json&#34;.format(positions_filename), &#34;w&#34;) as jout:
            json.dump(pos_out, jout, indent=4)

    log.info(&#34;Layout set\n-----\n&#34;)

    if return_positions_only is True:
        return position

    log.info(&#34;Got node positions .....&#34;)
    fig = plt.figure(figsize=figure_size)
    ax = plt.gca()

    log.info(&#34;Plotting .....&#34;)
    nx.draw(
        g,
        position,
        with_labels=False,
        node_color=node_colours,
        node_size=node_size,
        cmap=cmap,
        vmin=0.0,
        vmax=1.0,
        ax=ax,
    )

    plot_filename = &#34;{}_plot&#34;.format(file_name_no_extension)
    if not os.path.isfile(&#34;{}.png&#34;.format(plot_filename)):
        fig.savefig(&#34;{}_plot.png&#34;.format(file_name_no_extension))
    else:
        current_time = time.strftime(&#34;%-Y%m-%d-%H-%M-%S&#34;)
        plot_filename = &#34;{}_{}&#34;.format(plot_filename, current_time)
        log.info(&#34;File already existed will save to {}.png&#34;.format(plot_filename))
        fig.savefig(&#34;{}_plot.png&#34;.format(plot_filename))

    if return_image_only is True:
        return fig
    else:
        return position, fig


def close_n_nodes(
    pos: dict, centre: list = (0.0, 0.0), close: float = None, topn: int = 10,
) -&gt; list:
    &#34;&#34;&#34;
    From a dictionary of graph node positions (pos in the notebook) return a ranked list of n
    :param centre: np.ndarray - central point around which to find the nearest n points with in the threshold
    :param close: float - threshold for close if None just find the closest n
    :param topn: int - the number of points to find if None return all within close
    :return:
    &#34;&#34;&#34;
    log = logging.getLogger(__name__)

    close_nodes = []

    if not isinstance(centre, np.ndarray):
        centre = np.array(centre)

    if close is not None:
        for k, node in pos.items():
            d = np.linalg.norm(centre - node, 2)

            if d &lt; close:
                log.debug(&#34;Close node: {}&#34;.format(k))
                close_nodes.append(np.array([d, k]))
    else:
        for k, node in pos.items():
            d = np.linalg.norm(centre - node, 2)
            log.debug(&#34;Node distance: {}&#34;.format(k))
            close_nodes.append(np.array([d, k]))

    close_nodes = np.array(close_nodes)

    if topn is not None:
        sorted_close_nodes = close_nodes[np.argsort(close_nodes[:, 0])]
        close_node_keys = [int(ent) for ent in sorted_close_nodes[:topn, 1]]
    else:
        sorted_close_nodes = close_nodes[np.argsort(close_nodes[:, 0])]
        close_node_keys = [int(ent) for ent in sorted_close_nodes[:, 1]]

    return close_node_keys


def plot_image_annotated_chemical_space(
    g: nx.Graph,
    position: dict,
    ax: plt.axes,
    close_node_keys: list,
    property_key: str = &#34;prop&#34;,
    x_axes_fraction_fixed: list = [-0.25, -0.05],
    yaxes_fraction_increments: list = [
        1.0,
        0.8,
        0.6,
        0.4,
        0.2,
        0.0,
        -0.2,
        -0.4,
        -0.6,
        -0.8,
        -1.0,
    ],
    size: tuple = (150, 150),
    arrow: dict = dict(arrowstyle=&#34;simple&#34;,
                       facecolor=&#34;grey&#34;, edgecolor=&#34;grey&#34;),
):
    &#34;&#34;&#34;
    Function to add molecule images to the chemical space images
    :param g: networkx graph - networkx graph
    :param position: dict - positions of the nodes
    :param ax: matplotlib.axes - plot axes
    :param close_node_keys: list - keys of nodes close to one another on the grapg projection
    :param property_key: str - property in each node to include in the legend
    :param x_axes_fraction_fixed: float - x axis fixed position
    :param yaxes_fraction_increments: list y axis values to place images on should be one fore each image
    :param size: iterable - sizes of the indivdual molecules images
    :return: matplotlib.axes
    &#34;&#34;&#34;

    log = logging.getLogger(__name__)

    if isinstance(yaxes_fraction_increments, tuple):
        yaxes_fraction_increments = list(yaxes_fraction_increments)

    gridimages = [
        (x, y) for x in x_axes_fraction_fixed for y in yaxes_fraction_increments
    ]

    if len(gridimages) &lt; len(close_node_keys):
        log.warning(
            &#34;Too few grid places for molecules close to node, this will cause an index error. Increase the number of grid places&#34;,
        )

    for ith, cnk in enumerate(close_node_keys):
        # Get a molecule image from RDKit grid image so we can add a legend
        log.info(&#34;Ith {}: close node k {}&#34;.format(ith, cnk))
        message = &#34;{}\n{}&#34;.format(
            g.nodes()[cnk][&#34;smiles&#34;], g.nodes()[cnk][property_key],
        )
        log.info(&#34;plotting and adding legend {}&#34;.format(message))
        grid = Chem.Draw.MolsToGridImage(
            [
                mai.smiles_to_molecule(
                    g.nodes()[cnk][&#34;smiles&#34;], threed=False, addH=False,
                ),
            ],
            molsPerRow=1,
            subImgSize=size,
            legends=[message],
            useSVG=False,
            returnPNG=False,
            # maxMols=1
        )

        # Get an offset box in matplotlib add the image and legend as an annotation to the chemical space graph
        im_box = OffsetImage(grid)
        im_box.image.axes = ax
        log.info(&#34;Node of smiles position {}&#34;.format(position[cnk]))

        ab = AnnotationBbox(
            im_box,
            position[cnk],
            xybox=gridimages[ith],
            xycoords=&#34;data&#34;,
            boxcoords=&#34;axes fraction&#34;,
            pad=0.55,
            frameon=False,
            arrowprops=arrow,
        )

        # Add the artist to the image
        ax.add_artist(ab)

    return ax


def plot_annotated_chemical_space(
    df: pd.DataFrame,
    prop_key: str = &#34;property&#34;,
    smiles_key: str = &#34;smiles&#34;,
    label_key: str = &#34;names&#34;,
    closest_n: int = 4,
    centroid: list = (0.0, 0.0),
    connection_threshold: float = 0.7,
) -&gt; (nx.Graph, dict, plt.axes):
    &#34;&#34;&#34;
    Wrapper function to allow graoh building, plotting and annotation in a single call.
    :param df: pandas dataframe - dataframe with at least a label column, smiles column and property column
    :param prop_key: str - column key for property of interest values
    :param smiles_key: str - column key for smiles of molecule srings
    :param label_key: str - column key for each entries labels
    :param centroid: tuple - point around which to look for closest_n and annotate them
    :param closest_n: int - Number of points to look for around the centroid for annotation
    :param connection_threshold: float - connection threshold points with a tanimoto similarity &gt;=
                                         the threshold are connected
    :return:
    &#34;&#34;&#34;

    log = logging.getLogger(__name__)

    log.info(&#34;Starting chemical space plotting&#34;)
    log.info(f&#34;{prop_key} {smiles_key} {label_key}&#34;)
    log.info(f&#34;{df}&#34;)
    g = build_nx_graph(
        df,
        prop_key=prop_key,
        smiles_key=smiles_key,
        label_key=label_key,
        connection_threshold=connection_threshold,
    )
    pos, fig = plot_graph(g, weight=&#34;weight&#34;)
    close_by_nodes = close_n_nodes(pos, centre=centroid, topn=closest_n)
    ax = fig.gca()
    ax = plot_image_annotated_chemical_space(g, pos, ax, close_by_nodes)

    return g, pos, ax


if __name__ == &#34;__main__&#34;:
    import doctest

    doctest.testmod()</code></pre>
</details>
</section>
<section>
</section>
<section>
</section>
<section>
<h2 class="section-title" id="header-functions">Functions</h2>
<dl>
<dt id="ccsfp.informatics.chemical_space_map.build_nx_graph"><code class="name flex">
<span>def <span class="ident">build_nx_graph</span></span>(<span>df: pd.DataFrame, prop_key: str = 'property', smiles_key: str = 'smiles', label_key: str = 'names', distance: bool = False, fingerprints: list = None, connection_threshold: float = 0.7, connect_all: bool = False, graph_file_name: str = None, similarity_distance_list: list = None, node_attributes: list = None) ‑> networkx.classes.graph.Graph</span>
</code></dt>
<dd>
<div class="desc"><p>Function to build a defualt graph for chemical space map plots
:param df: pandas dataframe - dataframe with at least a label column, smiles column and property column
:param prop_key: str - column key for property of interest values
:param smiles_key: str - column key for smiles of molecule srings
:param label_key: str - column key for each entries labels
:param distance: bool - use distance rather than similarity (distance = 1.0 - similarity)
:param fingerprints: list - if None will use Morgan fingerprint radius 2 and 2048 bits users can input a list
otherwise of precomputed fingerprints from RDkit or ccsfp finger_print module should
be an RDKit ExplicitBitVect
:param connection_threshold: float - the value that must be &gt;= the similarity of distance to connect (form an edge)
between two nodes
:param connect_all: bool - connect all nodes with and apply to edge colour the value of grey those edges that don't
meet the threshold
:param graph_file_name: str - if None don't save a pickle (pkl) of the graph other wise save a pkl file of the graph
with this filename
:param similarity_distance_list: list - pre-computed list of the similarity or distance list if none these are
computed as Tanimoto similarities or distances
:param node_attributes: : list of dicts - Should be in the same order as the rows of the df the list index which
maps to the row index of df will have its dictionary added as node
attributes
:return: networkx.Graph() object</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def build_nx_graph(
    df: pd.DataFrame,
    prop_key: str = &#34;property&#34;,
    smiles_key: str = &#34;smiles&#34;,
    label_key: str = &#34;names&#34;,
    distance: bool = False,
    fingerprints: list = None,
    connection_threshold: float = 0.7,
    connect_all: bool = False,
    graph_file_name: str = None,
    similarity_distance_list: list = None,
    node_attributes: list = None,
) -&gt; nx.Graph:
    &#34;&#34;&#34;
    Function to build a defualt graph for chemical space map plots
    :param df: pandas dataframe - dataframe with at least a label column, smiles column and property column
    :param prop_key: str - column key for property of interest values
    :param smiles_key: str - column key for smiles of molecule srings
    :param label_key: str - column key for each entries labels
    :param distance: bool - use distance rather than similarity (distance = 1.0 - similarity)
    :param fingerprints: list - if None will use Morgan fingerprint radius 2 and 2048 bits users can input a list
                                otherwise of precomputed fingerprints from RDkit or ccsfp finger_print module should
                                be an RDKit ExplicitBitVect
    :param connection_threshold: float - the value that must be &gt;= the similarity of distance to connect (form an edge)
                                         between two nodes
    :param connect_all: bool - connect all nodes with and apply to edge colour the value of grey those edges that don&#39;t
                               meet the threshold
    :param graph_file_name: str - if None don&#39;t save a pickle (pkl) of the graph other wise save a pkl file of the graph
                                  with this filename
    :param similarity_distance_list: list - pre-computed list of the similarity or distance list if none these are
                                            computed as Tanimoto similarities or distances
    :param node_attributes: : list of dicts - Should be in the same order as the rows of the df the list index which
                                              maps to the row index of df will have its dictionary added as node
                                              attributes
    :return: networkx.Graph() object
    &#34;&#34;&#34;

    log = logging.Logger(__name__)

    log.info(
        &#34;Starting to build the chemical space graph, this can take quite some time .....&#34;,
    )
    if fingerprints is None:
        log.info(
            &#34;No fingerprints given by user, will use Morgan circular fingerprints radius 2 bit length 2048.&#34;,
        )
        fps = [
            AllChem.GetMorganFingerprintAsBitVect(
                Chem.MolFromSmiles(s), radius=2, nBits=2048,
            )
            for s in df[smiles_key].values
        ]
    else:
        fps = fingerprints

    log.info(&#34;Fingerprints: {}&#34;.format(fps))

    if similarity_distance_list is None:
        log.info(&#34;No smilarity/distance list given by user, will use Tanimoto metric&#34;)
        tc = [
            DataStructs.cDataStructs.BulkTanimotoSimilarity(fps[inx], fps)
            for inx in range(len(fps))
        ]
    else:
        tc = similarity_distance_list

    log.info(&#34;Tanimoto similarity: {}&#34;.format(tc))

    # similarity or distance metrics - Not if you want to use a custom distance leave distance as False and pass in
    df_weights = pd.DataFrame(data=np.array(tc))
    if distance is True:
        df_weights = 1.0 - df_weights

    # initialize graph
    g = nx.Graph()

    # Start to build the graph with the nodes from the raw data
    if node_attributes is not None:
        for index, row in df.iterrows():
            log.debug(&#34;Index: {}&#34;.format(index))

            na = node_attributes[index]
            if not isinstance(dict, na):
                log.warning(
                    &#34;WARNING - node_attribute index {} is not a dictionary {}\n{}&#34;.format(
                        index, type(na), na,
                    ),
                )
                raise RuntimeError(
                    &#34;ERROR - node attribute {} is not a dictionary&#34;.format(
                        index),
                )

            m = mai.smiles_to_molecule(row[smiles_key])

            g.add_node(
                index,
                smiles=row[smiles_key],
                name=row[label_key],
                fingerprint=fps[index],
                fingerprint_string=fp.bits_to_text(fps[index]),
                inchi=Chem.inchi.MolToInchi(m),
                inchikey=Chem.inchi.MolToInchiKey(m),
                mr=Chem.rdMolDescriptors.CalcExactMolWt(m),
                prop=row[prop_key],
                **na,
            )

    else:
        for index, row in df.iterrows():
            log.debug(&#34;Index: {}&#34;.format(index))

            m = mai.smiles_to_molecule(row[smiles_key])

            g.add_node(
                index,
                smiles=row[smiles_key],
                name=row[label_key],
                fingerprint=fps[index],
                fingerprint_string=fp.bits_to_text(fps[index]),
                inchi=Chem.inchi.MolToInchi(m),
                inchikey=Chem.inchi.MolToInchiKey(m),
                mr=Chem.rdMolDescriptors.CalcExactMolWt(m),
                prop=row[prop_key],
            )

    log.info(&#34;Number of nodes {}&#34;.format(len(list(g.nodes))))

    # Add connections
    edges = []

    if connect_all is True:
        log.info(&#34;Connecting all&#34;)

    for i in df_weights.index:
        for j in df_weights.index[i + 1:]:
            log.debug(&#34;Considering connection between node {} {}&#34;.format(i, j))
            if df_weights.loc[i, j] &gt;= connection_threshold:
                edges.append(
                    (i, j, {&#34;weight&#34;: df_weights.loc[i, j], &#34;color&#34;: &#34;blue&#34;}))
            else:
                if connect_all is True:
                    edges.append(
                        (i, j, {
                         &#34;weight&#34;: df_weights.loc[i, j], &#34;color&#34;: &#34;grey&#34;}),
                    )

    g.add_edges_from(edges)

    if graph_file_name is not None:
        if not os.path.isfile(graph_file_name):
            nx.readwrite.gpickle.write_gpickle(g, graph_file_name)
        else:
            current_time = time.strftime(&#34;%-Y%m-%d-%H-%M-%S&#34;)
            graph_file_name = &#34;{}_{}.pkl&#34;.format(graph_file_name, current_time)
            log.info(&#34;File already existed will save to {}&#34;.format(
                graph_file_name))
            nx.readwrite.gpickle.write_gpickle(g, graph_file_name)

    return g</code></pre>
</details>
</dd>
<dt id="ccsfp.informatics.chemical_space_map.close_n_nodes"><code class="name flex">
<span>def <span class="ident">close_n_nodes</span></span>(<span>pos: dict, centre: list = (0.0, 0.0), close: float = None, topn: int = 10) ‑> list</span>
</code></dt>
<dd>
<div class="desc"><p>From a dictionary of graph node positions (pos in the notebook) return a ranked list of n
:param centre: np.ndarray - central point around which to find the nearest n points with in the threshold
:param close: float - threshold for close if None just find the closest n
:param topn: int - the number of points to find if None return all within close
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def close_n_nodes(
    pos: dict, centre: list = (0.0, 0.0), close: float = None, topn: int = 10,
) -&gt; list:
    &#34;&#34;&#34;
    From a dictionary of graph node positions (pos in the notebook) return a ranked list of n
    :param centre: np.ndarray - central point around which to find the nearest n points with in the threshold
    :param close: float - threshold for close if None just find the closest n
    :param topn: int - the number of points to find if None return all within close
    :return:
    &#34;&#34;&#34;
    log = logging.getLogger(__name__)

    close_nodes = []

    if not isinstance(centre, np.ndarray):
        centre = np.array(centre)

    if close is not None:
        for k, node in pos.items():
            d = np.linalg.norm(centre - node, 2)

            if d &lt; close:
                log.debug(&#34;Close node: {}&#34;.format(k))
                close_nodes.append(np.array([d, k]))
    else:
        for k, node in pos.items():
            d = np.linalg.norm(centre - node, 2)
            log.debug(&#34;Node distance: {}&#34;.format(k))
            close_nodes.append(np.array([d, k]))

    close_nodes = np.array(close_nodes)

    if topn is not None:
        sorted_close_nodes = close_nodes[np.argsort(close_nodes[:, 0])]
        close_node_keys = [int(ent) for ent in sorted_close_nodes[:topn, 1]]
    else:
        sorted_close_nodes = close_nodes[np.argsort(close_nodes[:, 0])]
        close_node_keys = [int(ent) for ent in sorted_close_nodes[:, 1]]

    return close_node_keys</code></pre>
</details>
</dd>
<dt id="ccsfp.informatics.chemical_space_map.plot_annotated_chemical_space"><code class="name flex">
<span>def <span class="ident">plot_annotated_chemical_space</span></span>(<span>df: pd.DataFrame, prop_key: str = 'property', smiles_key: str = 'smiles', label_key: str = 'names', closest_n: int = 4, centroid: list = (0.0, 0.0), connection_threshold: float = 0.7) ‑> (nx.Graph, dict, plt.axes)</span>
</code></dt>
<dd>
<div class="desc"><p>Wrapper function to allow graoh building, plotting and annotation in a single call.
:param df: pandas dataframe - dataframe with at least a label column, smiles column and property column
:param prop_key: str - column key for property of interest values
:param smiles_key: str - column key for smiles of molecule srings
:param label_key: str - column key for each entries labels
:param centroid: tuple - point around which to look for closest_n and annotate them
:param closest_n: int - Number of points to look for around the centroid for annotation
:param connection_threshold: float - connection threshold points with a tanimoto similarity &gt;=
the threshold are connected
:return:</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_annotated_chemical_space(
    df: pd.DataFrame,
    prop_key: str = &#34;property&#34;,
    smiles_key: str = &#34;smiles&#34;,
    label_key: str = &#34;names&#34;,
    closest_n: int = 4,
    centroid: list = (0.0, 0.0),
    connection_threshold: float = 0.7,
) -&gt; (nx.Graph, dict, plt.axes):
    &#34;&#34;&#34;
    Wrapper function to allow graoh building, plotting and annotation in a single call.
    :param df: pandas dataframe - dataframe with at least a label column, smiles column and property column
    :param prop_key: str - column key for property of interest values
    :param smiles_key: str - column key for smiles of molecule srings
    :param label_key: str - column key for each entries labels
    :param centroid: tuple - point around which to look for closest_n and annotate them
    :param closest_n: int - Number of points to look for around the centroid for annotation
    :param connection_threshold: float - connection threshold points with a tanimoto similarity &gt;=
                                         the threshold are connected
    :return:
    &#34;&#34;&#34;

    log = logging.getLogger(__name__)

    log.info(&#34;Starting chemical space plotting&#34;)
    log.info(f&#34;{prop_key} {smiles_key} {label_key}&#34;)
    log.info(f&#34;{df}&#34;)
    g = build_nx_graph(
        df,
        prop_key=prop_key,
        smiles_key=smiles_key,
        label_key=label_key,
        connection_threshold=connection_threshold,
    )
    pos, fig = plot_graph(g, weight=&#34;weight&#34;)
    close_by_nodes = close_n_nodes(pos, centre=centroid, topn=closest_n)
    ax = fig.gca()
    ax = plot_image_annotated_chemical_space(g, pos, ax, close_by_nodes)

    return g, pos, ax</code></pre>
</details>
</dd>
<dt id="ccsfp.informatics.chemical_space_map.plot_graph"><code class="name flex">
<span>def <span class="ident">plot_graph</span></span>(<span>g: nx.Graph, opt_dist: float = None, weight: str = None, iterations: int = 50, random_seed: int = 7, figure_size: tuple = (20, 20), node_colours: str = 'b', node_size: int = 20, cmap: plt.cm = &lt;matplotlib.colors.LinearSegmentedColormap object&gt;, file_name_no_extension: str = 'graph', return_positions_only: bool = False, return_image_only: bool = False)</span>
</code></dt>
<dd>
<div class="desc"><p>A function to set node positions using the spring layout. This is a deterministic layout (if you set the seed) using
a form of annealing. It uses the Fruchterman-Reingold force-directed algorithm. In simple terms the algorithm treats
nodes as repulsive, connected nodes (i.e. they share an edge) are attracted to one another using the weight factor,
if specified, where weight is the edge attribute holding a float as attractive strength. If weight is None all
connected nodes are equally attractive, larger weight means more attractive. The opt_dist sets the optimal distance
between nodes
:param g: networkx Graph - Graph instance
:param opt_dist: float - Optimal distance between nodes
:param weight: str - edge attribute to use to determine the attractive force between nodes
:param iterations: int - Number of annealing iterations to use
:param random_seed: int - seed for node positions
:param figure_size: tuple - size of the graph image
:param node_colours: str or list - single colour str in matplotlib format or list of specific colours for each node
in order of the node numbers
:param node_size: int - Size of the nodes in the image
:param cmap: matplotlib colormap - colormap
:param file_name_no_extension: str - string to use to save positions and image to without an extension
:param return_positions_only: bool - return only the positions not an image of the graph
:param return_image_only: - return only and image not the positions
:return: return_positions_only=False and return_image_only=False then return = dict, matplotlib figure
return_positions_only=True and return_image_only=False then return = dict
return_positions_only=False and return_image_only=True then return = matplotlib figure
return_positions_only=True and return_image_only=True then return = dict</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_graph(
    g: nx.Graph,
    opt_dist: float = None,
    weight: str = None,
    iterations: int = 50,
    random_seed: int = 7,
    figure_size: tuple = (20, 20),
    node_colours: str = &#34;b&#34;,
    node_size: int = 20,
    cmap: plt.cm = plt.cm.rainbow,
    file_name_no_extension: str = &#34;graph&#34;,
    return_positions_only: bool = False,
    return_image_only: bool = False,
):
    &#34;&#34;&#34;
    A function to set node positions using the spring layout. This is a deterministic layout (if you set the seed) using
    a form of annealing. It uses the Fruchterman-Reingold force-directed algorithm. In simple terms the algorithm treats
    nodes as repulsive, connected nodes (i.e. they share an edge) are attracted to one another using the weight factor,
    if specified, where weight is the edge attribute holding a float as attractive strength. If weight is None all
    connected nodes are equally attractive, larger weight means more attractive. The opt_dist sets the optimal distance
    between nodes
    :param g: networkx Graph - Graph instance
    :param opt_dist: float - Optimal distance between nodes
    :param weight: str - edge attribute to use to determine the attractive force between nodes
    :param iterations: int - Number of annealing iterations to use
    :param random_seed: int - seed for node positions
    :param figure_size: tuple - size of the graph image
    :param node_colours: str or list - single colour str in matplotlib format or list of specific colours for each node
                                       in order of the node numbers
    :param node_size: int - Size of the nodes in the image
    :param cmap: matplotlib colormap - colormap
    :param file_name_no_extension: str - string to use to save positions and image to without an extension
    :param return_positions_only: bool - return only the positions not an image of the graph
    :param return_image_only: - return only and image not the positions
    :return: return_positions_only=False and return_image_only=False then return = dict, matplotlib figure
             return_positions_only=True and return_image_only=False then return = dict
             return_positions_only=False and return_image_only=True then return = matplotlib figure
             return_positions_only=True and return_image_only=True then return = dict
    &#34;&#34;&#34;

    log = logging.getLogger(__name__)

    log.info(&#34;Setting nodes .....&#34;)
    position = nx.spring_layout(
        g, k=opt_dist, weight=weight, iterations=iterations, seed=random_seed,
    )

    pos_out = {k: ent.tolist() for k, ent in position.items()}

    positions_filename = &#34;{}_positions&#34;.format(file_name_no_extension)
    if not os.path.isfile(&#34;{}.json&#34;.format(positions_filename)):
        with open(&#34;{}.json&#34;.format(positions_filename), &#34;w&#34;) as jout:
            json.dump(pos_out, jout, indent=4)
    else:
        current_time = time.strftime(&#34;%-Y%m-%d-%H-%M-%S&#34;)
        positions_filename = &#34;{}_{}&#34;.format(positions_filename, current_time)
        log.info(&#34;File already existed will save to {}.json&#34;.format(
            positions_filename))
        with open(&#34;{}.json&#34;.format(positions_filename), &#34;w&#34;) as jout:
            json.dump(pos_out, jout, indent=4)

    log.info(&#34;Layout set\n-----\n&#34;)

    if return_positions_only is True:
        return position

    log.info(&#34;Got node positions .....&#34;)
    fig = plt.figure(figsize=figure_size)
    ax = plt.gca()

    log.info(&#34;Plotting .....&#34;)
    nx.draw(
        g,
        position,
        with_labels=False,
        node_color=node_colours,
        node_size=node_size,
        cmap=cmap,
        vmin=0.0,
        vmax=1.0,
        ax=ax,
    )

    plot_filename = &#34;{}_plot&#34;.format(file_name_no_extension)
    if not os.path.isfile(&#34;{}.png&#34;.format(plot_filename)):
        fig.savefig(&#34;{}_plot.png&#34;.format(file_name_no_extension))
    else:
        current_time = time.strftime(&#34;%-Y%m-%d-%H-%M-%S&#34;)
        plot_filename = &#34;{}_{}&#34;.format(plot_filename, current_time)
        log.info(&#34;File already existed will save to {}.png&#34;.format(plot_filename))
        fig.savefig(&#34;{}_plot.png&#34;.format(plot_filename))

    if return_image_only is True:
        return fig
    else:
        return position, fig</code></pre>
</details>
</dd>
<dt id="ccsfp.informatics.chemical_space_map.plot_image_annotated_chemical_space"><code class="name flex">
<span>def <span class="ident">plot_image_annotated_chemical_space</span></span>(<span>g: nx.Graph, position: dict, ax: plt.axes, close_node_keys: list, property_key: str = 'prop', x_axes_fraction_fixed: list = [-0.25, -0.05], yaxes_fraction_increments: list = [1.0, 0.8, 0.6, 0.4, 0.2, 0.0, -0.2, -0.4, -0.6, -0.8, -1.0], size: tuple = (150, 150), arrow: dict = {'arrowstyle': 'simple', 'facecolor': 'grey', 'edgecolor': 'grey'})</span>
</code></dt>
<dd>
<div class="desc"><p>Function to add molecule images to the chemical space images
:param g: networkx graph - networkx graph
:param position: dict - positions of the nodes
:param ax: matplotlib.axes - plot axes
:param close_node_keys: list - keys of nodes close to one another on the grapg projection
:param property_key: str - property in each node to include in the legend
:param x_axes_fraction_fixed: float - x axis fixed position
:param yaxes_fraction_increments: list y axis values to place images on should be one fore each image
:param size: iterable - sizes of the indivdual molecules images
:return: matplotlib.axes</p></div>
<details class="source">
<summary>
<span>Expand source code</span>
</summary>
<pre><code class="python">def plot_image_annotated_chemical_space(
    g: nx.Graph,
    position: dict,
    ax: plt.axes,
    close_node_keys: list,
    property_key: str = &#34;prop&#34;,
    x_axes_fraction_fixed: list = [-0.25, -0.05],
    yaxes_fraction_increments: list = [
        1.0,
        0.8,
        0.6,
        0.4,
        0.2,
        0.0,
        -0.2,
        -0.4,
        -0.6,
        -0.8,
        -1.0,
    ],
    size: tuple = (150, 150),
    arrow: dict = dict(arrowstyle=&#34;simple&#34;,
                       facecolor=&#34;grey&#34;, edgecolor=&#34;grey&#34;),
):
    &#34;&#34;&#34;
    Function to add molecule images to the chemical space images
    :param g: networkx graph - networkx graph
    :param position: dict - positions of the nodes
    :param ax: matplotlib.axes - plot axes
    :param close_node_keys: list - keys of nodes close to one another on the grapg projection
    :param property_key: str - property in each node to include in the legend
    :param x_axes_fraction_fixed: float - x axis fixed position
    :param yaxes_fraction_increments: list y axis values to place images on should be one fore each image
    :param size: iterable - sizes of the indivdual molecules images
    :return: matplotlib.axes
    &#34;&#34;&#34;

    log = logging.getLogger(__name__)

    if isinstance(yaxes_fraction_increments, tuple):
        yaxes_fraction_increments = list(yaxes_fraction_increments)

    gridimages = [
        (x, y) for x in x_axes_fraction_fixed for y in yaxes_fraction_increments
    ]

    if len(gridimages) &lt; len(close_node_keys):
        log.warning(
            &#34;Too few grid places for molecules close to node, this will cause an index error. Increase the number of grid places&#34;,
        )

    for ith, cnk in enumerate(close_node_keys):
        # Get a molecule image from RDKit grid image so we can add a legend
        log.info(&#34;Ith {}: close node k {}&#34;.format(ith, cnk))
        message = &#34;{}\n{}&#34;.format(
            g.nodes()[cnk][&#34;smiles&#34;], g.nodes()[cnk][property_key],
        )
        log.info(&#34;plotting and adding legend {}&#34;.format(message))
        grid = Chem.Draw.MolsToGridImage(
            [
                mai.smiles_to_molecule(
                    g.nodes()[cnk][&#34;smiles&#34;], threed=False, addH=False,
                ),
            ],
            molsPerRow=1,
            subImgSize=size,
            legends=[message],
            useSVG=False,
            returnPNG=False,
            # maxMols=1
        )

        # Get an offset box in matplotlib add the image and legend as an annotation to the chemical space graph
        im_box = OffsetImage(grid)
        im_box.image.axes = ax
        log.info(&#34;Node of smiles position {}&#34;.format(position[cnk]))

        ab = AnnotationBbox(
            im_box,
            position[cnk],
            xybox=gridimages[ith],
            xycoords=&#34;data&#34;,
            boxcoords=&#34;axes fraction&#34;,
            pad=0.55,
            frameon=False,
            arrowprops=arrow,
        )

        # Add the artist to the image
        ax.add_artist(ab)

    return ax</code></pre>
</details>
</dd>
</dl>
</section>
<section>
</section>
</article>
<nav id="sidebar">
<h1>Index</h1>
<div class="toc">
<ul></ul>
</div>
<ul id="index">
<li><h3>Super-module</h3>
<ul>
<li><code><a title="ccsfp.informatics" href="index.html">ccsfp.informatics</a></code></li>
</ul>
</li>
<li><h3><a href="#header-functions">Functions</a></h3>
<ul class="">
<li><code><a title="ccsfp.informatics.chemical_space_map.build_nx_graph" href="#ccsfp.informatics.chemical_space_map.build_nx_graph">build_nx_graph</a></code></li>
<li><code><a title="ccsfp.informatics.chemical_space_map.close_n_nodes" href="#ccsfp.informatics.chemical_space_map.close_n_nodes">close_n_nodes</a></code></li>
<li><code><a title="ccsfp.informatics.chemical_space_map.plot_annotated_chemical_space" href="#ccsfp.informatics.chemical_space_map.plot_annotated_chemical_space">plot_annotated_chemical_space</a></code></li>
<li><code><a title="ccsfp.informatics.chemical_space_map.plot_graph" href="#ccsfp.informatics.chemical_space_map.plot_graph">plot_graph</a></code></li>
<li><code><a title="ccsfp.informatics.chemical_space_map.plot_image_annotated_chemical_space" href="#ccsfp.informatics.chemical_space_map.plot_image_annotated_chemical_space">plot_image_annotated_chemical_space</a></code></li>
</ul>
</li>
</ul>
</nav>
</main>
<footer id="footer">
<p>Generated by <a href="https://pdoc3.github.io/pdoc" title="pdoc: Python API documentation generator"><cite>pdoc</cite> 0.10.0</a>.</p>
</footer>
</body>
</html>
